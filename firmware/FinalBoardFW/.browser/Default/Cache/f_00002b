{"html":"\n      <article>\n        <div class=\"header\">\n  \n  <div class=\"headertitle\">\n  <h1 class=\"title\">I2C - Inter-Integrated Circuit<\/h1><\/div>\n<\/div><!--header-->\n<div class=\"contents\">\n<a name=\"details\" id=\"details\"><\/a><h2 class=\"groupheader\">Description<\/h2>\n<p>Inter-integrated Circuit (I2C) Peripheral API. <\/p>\n<p>This module contains functions to control the I2C peripheral of Silicon Labs 32-bit MCUs and SoCs. The I2C interface allows communication on I2C buses with the lowest energy consumption possible. <\/p>\n<table class=\"memberdecls\">\n<tbody><tr class=\"heading\"><td colspan=\"2\"><h2 class=\"groupheader\"><a name=\"nested-classes\"><\/a>\nData Structures<\/h2><\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">struct &nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"http://docs.silabs.com/gecko-platform/4.1/emlib/api/efr32xg24/struct-i2-c-init-type-def\" class=\"el\" target=\"_blank\">I2C_Init_TypeDef<\/a><\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">I2C initialization structure.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">struct &nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"http://docs.silabs.com/gecko-platform/4.1/emlib/api/efr32xg24/struct-i2-c-transfer-seq-type-def\" class=\"el\" target=\"_blank\">I2C_TransferSeq_TypeDef<\/a><\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Master mode transfer message structure used to define a complete I2C transfer sequence (from start to stop).  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<\/tbody><\/table><table class=\"memberdecls\">\n<tbody><tr class=\"heading\"><td colspan=\"2\"><h2 class=\"groupheader\"><a name=\"func-members\"><\/a>\nFunctions<\/h2><\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">uint32_t&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#gaf2563ff04d4b24825a6c67f9ec4dcb80\" class=\"el\">I2C_BusFreqGet<\/a> (I2C_TypeDef *i2c)<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Get the current configured I2C bus frequency.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">void&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#ga02fbf32736b2e6c756399ceeba9563a1\" class=\"el\">I2C_BusFreqSet<\/a> (I2C_TypeDef *i2c, uint32_t freqRef, uint32_t freqScl, <a href=\"#gabb1516548b4528328682d6be09a3e3a5\" class=\"el\">I2C_ClockHLR_TypeDef<\/a> i2cMode)<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Set the I2C bus frequency.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">void&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#gaca1c9ca46d6945a4696f8a34ab8c2ddf\" class=\"el\">I2C_Enable<\/a> (I2C_TypeDef *i2c, bool enable)<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Enable/disable I2C.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">void&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#gab52e0fc0d3690e40f80a193d5b6fdd51\" class=\"el\">I2C_Init<\/a> (I2C_TypeDef *i2c, const <a href=\"http://docs.silabs.com/gecko-platform/4.1/emlib/api/efr32xg24/struct-i2-c-init-type-def\" class=\"el\" target=\"_blank\">I2C_Init_TypeDef<\/a> *init)<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Initialize I2C.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">void&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#ga6cba16ae44e25e0e9f85e7fdf9f09956\" class=\"el\">I2C_IntClear<\/a> (I2C_TypeDef *i2c, uint32_t flags)<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Clear one or more pending I2C interrupts.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">void&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#gae2f663bf8e0a7dfe3f612ad9ed409260\" class=\"el\">I2C_IntDisable<\/a> (I2C_TypeDef *i2c, uint32_t flags)<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Disable one or more I2C interrupts.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">void&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#ga4e7ec23adf30a399590113d8b98ec4f1\" class=\"el\">I2C_IntEnable<\/a> (I2C_TypeDef *i2c, uint32_t flags)<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Enable one or more I2C interrupts.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">uint32_t&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#gad969f558d7a35d5235dd174c9eb3aed0\" class=\"el\">I2C_IntGet<\/a> (I2C_TypeDef *i2c)<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Get pending I2C interrupt flags.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">uint32_t&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#gab808cebf4e4caca28c4cf59b4d596b32\" class=\"el\">I2C_IntGetEnabled<\/a> (I2C_TypeDef *i2c)<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Get enabled and pending I2C interrupt flags.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">void&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#gab76ed891da5ae8e6736d22a9570cb4a5\" class=\"el\">I2C_IntSet<\/a> (I2C_TypeDef *i2c, uint32_t flags)<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Set one or more pending I2C interrupts from SW.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">void&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#ga602a1d2c64c05453bf9c1b1d52194678\" class=\"el\">I2C_Reset<\/a> (I2C_TypeDef *i2c)<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Reset I2C to the same state that it was in after a hardware reset.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">uint8_t&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#gab7373d2618562755e7f57753c824417e\" class=\"el\">I2C_SlaveAddressGet<\/a> (I2C_TypeDef *i2c)<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Get Target address used for I2C peripheral (when operating in Target mode).  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">void&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#gaf6c8d330247b9da600468307689f7df0\" class=\"el\">I2C_SlaveAddressSet<\/a> (I2C_TypeDef *i2c, uint8_t addr)<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Set Target address to use for I2C peripheral (when operating in Target mode).  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">uint8_t&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#gacb6d14f920b35944800b65b71347428c\" class=\"el\">I2C_SlaveAddressMaskGet<\/a> (I2C_TypeDef *i2c)<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Get Target address mask used for I2C peripheral (when operating in Target mode).  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">void&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#ga386dbe1bb286a066925936d131f255ec\" class=\"el\">I2C_SlaveAddressMaskSet<\/a> (I2C_TypeDef *i2c, uint8_t mask)<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Set Target address mask used for I2C peripheral (when operating in Target mode).  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a href=\"#ga7c781ec28ae11e3e28892de7aa07a00f\" class=\"el\">I2C_TransferReturn_TypeDef<\/a>&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#ga67983b3dbe7f028a97f765e421b3df56\" class=\"el\">I2C_Transfer<\/a> (I2C_TypeDef *i2c)<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Continue an initiated I2C transfer (single master mode only).  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a href=\"#ga7c781ec28ae11e3e28892de7aa07a00f\" class=\"el\">I2C_TransferReturn_TypeDef<\/a>&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#gae2bf2ecc3d0c4f55e3511d4871b64b16\" class=\"el\">I2C_TransferInit<\/a> (I2C_TypeDef *i2c, <a href=\"http://docs.silabs.com/gecko-platform/4.1/emlib/api/efr32xg24/struct-i2-c-transfer-seq-type-def\" class=\"el\" target=\"_blank\">I2C_TransferSeq_TypeDef<\/a> *seq)<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Prepare and start an I2C transfer (single master mode only).  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<\/tbody><\/table><table class=\"memberdecls\">\n<tbody><tr class=\"heading\"><td colspan=\"2\"><h2 class=\"groupheader\"><a name=\"define-members\"><\/a>\nMacros<\/h2><\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">#define&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#ga0a2167eb1e00a8da86bf0826f712f0f8\" class=\"el\">I2C_FREQ_STANDARD_MAX<\/a>&nbsp;&nbsp;&nbsp;100000<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Standard mode max frequency assuming using 4:4 ratio for Nlow:Nhigh.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">#define&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#ga29a3fbc14b30b68601118a9866e7440d\" class=\"el\">I2C_FREQ_FAST_MAX<\/a>&nbsp;&nbsp;&nbsp;392157<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Fast mode max frequency assuming using 6:3 ratio for Nlow:Nhigh.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">#define&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#ga6961334be5d2f1d6e98d8f48de3b040e\" class=\"el\">I2C_FREQ_FASTPLUS_MAX<\/a>&nbsp;&nbsp;&nbsp;987167<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Fast mode+ max frequency assuming using 11:6 ratio for Nlow:Nhigh.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">#define&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#ga091476f45133e8a6deb9dbd7a3ea6229\" class=\"el\">I2C_FLAG_WRITE<\/a>&nbsp;&nbsp;&nbsp;0x0001<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Indicate plain write sequence: S+ADDR(W)+DATA0+P.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">#define&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#ga0c1779663a5ebf44e956ea3f591b4e61\" class=\"el\">I2C_FLAG_READ<\/a>&nbsp;&nbsp;&nbsp;0x0002<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Indicate plain read sequence: S+ADDR(R)+DATA0+P.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">#define&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#gaf9fc47d6ee1c66405dc491f7a4c3b8fc\" class=\"el\">I2C_FLAG_WRITE_READ<\/a>&nbsp;&nbsp;&nbsp;0x0004<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Indicate combined write/read sequence: S+ADDR(W)+DATA0+Sr+ADDR(R)+DATA1+P.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">#define&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#ga28bb5f9d0559f3af24c0554e497ba2b3\" class=\"el\">I2C_FLAG_WRITE_WRITE<\/a>&nbsp;&nbsp;&nbsp;0x0008<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Indicate write sequence using two buffers: S+ADDR(W)+DATA0+DATA1+P.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">#define&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#ga6fd13e29a6b6315de051549037ac176f\" class=\"el\">I2C_FLAG_10BIT_ADDR<\/a>&nbsp;&nbsp;&nbsp;0x0010<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Use 10 bit address.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">#define&nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#ga5c7fbd27ef311914288d8e7ce02f1528\" class=\"el\">I2C_INIT_DEFAULT<\/a><\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Suggested default configuration for I2C initialization structure.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<\/tbody><\/table><table class=\"memberdecls\">\n<tbody><tr class=\"heading\"><td colspan=\"2\"><h2 class=\"groupheader\"><a name=\"enum-members\"><\/a>\nEnumerations<\/h2><\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">enum &nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#gabb1516548b4528328682d6be09a3e3a5\" class=\"el\">I2C_ClockHLR_TypeDef<\/a> { <br>\n&nbsp;&nbsp;<a href=\"#ggabb1516548b4528328682d6be09a3e3a5a72c81018da3424addf47b44341acd111\" class=\"el\">i2cClockHLRStandard<\/a> = _I2C_CTRL_CLHR_STANDARD, \n<br>\n&nbsp;&nbsp;<a href=\"#ggabb1516548b4528328682d6be09a3e3a5a7bfc41c09113d46c1247b598c80a3b2e\" class=\"el\">i2cClockHLRAsymetric<\/a> = _I2C_CTRL_CLHR_ASYMMETRIC, \n<br>\n&nbsp;&nbsp;<a href=\"#ggabb1516548b4528328682d6be09a3e3a5a177d1faa325c634cbf56d2a4b4de9425\" class=\"el\">i2cClockHLRFast<\/a> = _I2C_CTRL_CLHR_FAST\n<br>\n }<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Clock low to high ratio settings.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<tr class=\"memitem\"><td class=\"memItemLeft\" align=\"right\" valign=\"top\">enum &nbsp;<\/td><td class=\"memItemRight\" valign=\"bottom\"><a href=\"#ga7c781ec28ae11e3e28892de7aa07a00f\" class=\"el\">I2C_TransferReturn_TypeDef<\/a> { <br>\n&nbsp;&nbsp;<a href=\"#gga7c781ec28ae11e3e28892de7aa07a00fa1f1df5a76a71b423083d6a327d38ca1c\" class=\"el\">i2cTransferInProgress<\/a> = 1, \n<br>\n&nbsp;&nbsp;<a href=\"#gga7c781ec28ae11e3e28892de7aa07a00fa01149f9a11ada8a9b05e7104f873de66\" class=\"el\">i2cTransferDone<\/a> = 0, \n<br>\n&nbsp;&nbsp;<a href=\"#gga7c781ec28ae11e3e28892de7aa07a00fa54895c4189c89f4410a3ce1a15822725\" class=\"el\">i2cTransferNack<\/a> = -1, \n<br>\n&nbsp;&nbsp;<a href=\"#gga7c781ec28ae11e3e28892de7aa07a00fa75da099dd69e053ee12d38fdd76a22e6\" class=\"el\">i2cTransferBusErr<\/a> = -2, \n<br>\n&nbsp;&nbsp;<a href=\"#gga7c781ec28ae11e3e28892de7aa07a00fac15d6d57e2c8b0fca04fc6fbd80b824e\" class=\"el\">i2cTransferArbLost<\/a> = -3, \n<br>\n&nbsp;&nbsp;<a href=\"#gga7c781ec28ae11e3e28892de7aa07a00fa49fe8ab19b9167d78c4b2abec7a511fc\" class=\"el\">i2cTransferUsageFault<\/a> = -4, \n<br>\n&nbsp;&nbsp;<a href=\"#gga7c781ec28ae11e3e28892de7aa07a00faa5de823251279b281dcabbd1ec4f693d\" class=\"el\">i2cTransferSwFault<\/a> = -5\n<br>\n }<\/td><\/tr>\n<tr class=\"memdesc\"><td class=\"mdescLeft\">&nbsp;<\/td><td class=\"mdescRight\">Return codes for single Controller mode transfer function.  <br><\/td><\/tr>\n<tr class=\"separator\"><td class=\"memSeparator\" colspan=\"2\">&nbsp;<\/td><\/tr>\n<\/tbody><\/table>\n<h2 class=\"groupheader\">Function Documentation<\/h2>\n<a id=\"gaf2563ff04d4b24825a6c67f9ec4dcb80\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#gaf2563ff04d4b24825a6c67f9ec4dcb80\">◆&nbsp;<\/a><\/span>I2C_BusFreqGet()<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">uint32_t I2C_BusFreqGet <\/td>\n          <td>(<\/td>\n          <td class=\"paramtype\">I2C_TypeDef *&nbsp;<\/td>\n          <td class=\"paramname\"><code>i2c<\/code><\/td><td>)<\/td>\n          <td><\/td>\n        <\/tr>\n      <\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Get the current configured I2C bus frequency. <\/p>\n<p>This frequency is only relevant when acting as master.<\/p>\n<dl class=\"section note\"><dt>Note<\/dt><dd>The actual frequency is a real number, this function returns a rounded down (truncated) integer value.<\/dd><\/dl>\n<dl class=\"params\"><dt>Parameters<\/dt><dd>\n  <table class=\"params\">\n    <tbody><tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>i2c<\/code><\/td><td>A pointer to the I2C peripheral register block.<\/td><\/tr>\n  <\/tbody><\/table>\n  <\/dd>\n<\/dl>\n<dl class=\"section return\"><dt>Returns<\/dt><dd>The current I2C frequency in Hz. <\/dd><\/dl>\n\n<\/div>\n<\/div>\n<a id=\"ga02fbf32736b2e6c756399ceeba9563a1\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#ga02fbf32736b2e6c756399ceeba9563a1\">◆&nbsp;<\/a><\/span>I2C_BusFreqSet()<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">void I2C_BusFreqSet <\/td>\n          <td>(<\/td>\n          <td class=\"paramtype\">I2C_TypeDef *&nbsp;<\/td>\n          <td class=\"paramname\"><code>i2c, <\/code><\/td>\n        <\/tr>\n        <tr>\n          <td class=\"paramkey\"><\/td>\n          <td><\/td>\n          <td class=\"paramtype\">uint32_t&nbsp;<\/td>\n          <td class=\"paramname\"><code>freqRef, <\/code><\/td>\n        <\/tr>\n        <tr>\n          <td class=\"paramkey\"><\/td>\n          <td><\/td>\n          <td class=\"paramtype\">uint32_t&nbsp;<\/td>\n          <td class=\"paramname\"><code>freqScl, <\/code><\/td>\n        <\/tr>\n        <tr>\n          <td class=\"paramkey\"><\/td>\n          <td><\/td>\n          <td class=\"paramtype\"><a href=\"#gabb1516548b4528328682d6be09a3e3a5\" class=\"el\">I2C_ClockHLR_TypeDef<\/a>&nbsp;<\/td>\n          <td class=\"paramname\"><code>i2cMode&nbsp;<\/code><\/td>\n        <\/tr>\n        <tr>\n          <td><\/td>\n          <td>)<\/td>\n          <td><\/td><td><\/td>\n        <\/tr>\n      <\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Set the I2C bus frequency. <\/p>\n<p>The bus frequency is only relevant when acting as master. The bus frequency should not be set higher than the maximum frequency accepted by the slowest device on the bus.<\/p>\n<p>Notice that, due to asymmetric requirements on low and high I2C clock cycles in the I2C specification, the maximum frequency allowed to comply with the specification may be somewhat lower than expected.<\/p>\n<p>See the reference manual, details on I2C clock generation, for maximum allowed theoretical frequencies for different modes.<\/p>\n<dl class=\"params\"><dt>Parameters<\/dt><dd>\n  <table class=\"params\">\n    <tbody><tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>i2c<\/code><\/td><td>A pointer to the I2C peripheral register block.<\/td><\/tr>\n    <tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>freqRef<\/code><\/td><td>An I2C reference clock frequency in Hz that will be used. If set to 0, HFPERCLK / HFPERCCLK clock is used. Setting it to a higher than actual configured value has the consequence of reducing the real I2C frequency.<\/td><\/tr>\n    <tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>freqScl<\/code><\/td><td>A bus frequency to set (bus speed may be lower due to integer prescaling). Safe (according to the I2C specification) maximum frequencies for standard fast and fast+ modes are available using I2C_FREQ_ defines. (Using I2C_FREQ_ defines requires corresponding setting of <code>type<\/code>.) The slowest slave device on a bus must always be considered.<\/td><\/tr>\n    <tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>i2cMode<\/code><\/td><td>A clock low-to-high ratio type to use. If not using i2cClockHLRStandard, make sure all devices on the bus support the specified mode. Using a non-standard ratio is useful to achieve a higher bus clock in fast and fast+ modes. <\/td><\/tr>\n  <\/tbody><\/table>\n  <\/dd>\n<\/dl>\n\n<\/div>\n<\/div>\n<a id=\"gaca1c9ca46d6945a4696f8a34ab8c2ddf\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#gaca1c9ca46d6945a4696f8a34ab8c2ddf\">◆&nbsp;<\/a><\/span>I2C_Enable()<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">void I2C_Enable <\/td>\n          <td>(<\/td>\n          <td class=\"paramtype\">I2C_TypeDef *&nbsp;<\/td>\n          <td class=\"paramname\"><code>i2c, <\/code><\/td>\n        <\/tr>\n        <tr>\n          <td class=\"paramkey\"><\/td>\n          <td><\/td>\n          <td class=\"paramtype\">bool&nbsp;<\/td>\n          <td class=\"paramname\"><code>enable&nbsp;<\/code><\/td>\n        <\/tr>\n        <tr>\n          <td><\/td>\n          <td>)<\/td>\n          <td><\/td><td><\/td>\n        <\/tr>\n      <\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Enable/disable I2C. <\/p>\n<dl class=\"section note\"><dt>Note<\/dt><dd>After enabling the I2C (from being disabled), the I2C is in BUSY state.<\/dd><\/dl>\n<dl class=\"params\"><dt>Parameters<\/dt><dd>\n  <table class=\"params\">\n    <tbody><tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>i2c<\/code><\/td><td>A pointer to the I2C peripheral register block.<\/td><\/tr>\n    <tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>enable<\/code><\/td><td>True to enable counting, false to disable. <\/td><\/tr>\n  <\/tbody><\/table>\n  <\/dd>\n<\/dl>\n\n<\/div>\n<\/div>\n<a id=\"gab52e0fc0d3690e40f80a193d5b6fdd51\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#gab52e0fc0d3690e40f80a193d5b6fdd51\">◆&nbsp;<\/a><\/span>I2C_Init()<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">void I2C_Init <\/td>\n          <td>(<\/td>\n          <td class=\"paramtype\">I2C_TypeDef *&nbsp;<\/td>\n          <td class=\"paramname\"><code>i2c, <\/code><\/td>\n        <\/tr>\n        <tr>\n          <td class=\"paramkey\"><\/td>\n          <td><\/td>\n          <td class=\"paramtype\">const <a href=\"http://docs.silabs.com/gecko-platform/4.1/emlib/api/efr32xg24/struct-i2-c-init-type-def\" class=\"el\" target=\"_blank\">I2C_Init_TypeDef<\/a> *&nbsp;<\/td>\n          <td class=\"paramname\"><code>init&nbsp;<\/code><\/td>\n        <\/tr>\n        <tr>\n          <td><\/td>\n          <td>)<\/td>\n          <td><\/td><td><\/td>\n        <\/tr>\n      <\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Initialize I2C. <\/p>\n<dl class=\"params\"><dt>Parameters<\/dt><dd>\n  <table class=\"params\">\n    <tbody><tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>i2c<\/code><\/td><td>A pointer to the I2C peripheral register block.<\/td><\/tr>\n    <tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>init<\/code><\/td><td>A pointer to the I2C initialization structure. <\/td><\/tr>\n  <\/tbody><\/table>\n  <\/dd>\n<\/dl>\n\n<\/div>\n<\/div>\n<a id=\"ga6cba16ae44e25e0e9f85e7fdf9f09956\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#ga6cba16ae44e25e0e9f85e7fdf9f09956\">◆&nbsp;<\/a><\/span>I2C_IntClear()<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n<table class=\"mlabels\">\n  <tbody><tr>\n  <td class=\"mlabels-left\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">void I2C_IntClear <\/td>\n          <td>(<\/td>\n          <td class=\"paramtype\">I2C_TypeDef *&nbsp;<\/td>\n          <td class=\"paramname\"><code>i2c, <\/code><\/td>\n        <\/tr>\n        <tr>\n          <td class=\"paramkey\"><\/td>\n          <td><\/td>\n          <td class=\"paramtype\">uint32_t&nbsp;<\/td>\n          <td class=\"paramname\"><code>flags&nbsp;<\/code><\/td>\n        <\/tr>\n        <tr>\n          <td><\/td>\n          <td>)<\/td>\n          <td><\/td><td><\/td>\n        <\/tr>\n      <\/tbody><\/table>\n  <\/td>\n  <td class=\"mlabels-right\">\n<span class=\"mlabels\"><span class=\"mlabel\">inline<\/span><\/span>  <\/td>\n  <\/tr>\n<\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Clear one or more pending I2C interrupts. <\/p>\n<dl class=\"params\"><dt>Parameters<\/dt><dd>\n  <table class=\"params\">\n    <tbody><tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>i2c<\/code><\/td><td>Pointer to I2C peripheral register block.<\/td><\/tr>\n    <tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>flags<\/code><\/td><td>Pending I2C interrupt source to clear. Use a bitwise logic OR combination of valid interrupt flags for the I2C module (I2C_IF_nnn). <\/td><\/tr>\n  <\/tbody><\/table>\n  <\/dd>\n<\/dl>\n\n<\/div>\n<\/div>\n<a id=\"gae2f663bf8e0a7dfe3f612ad9ed409260\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#gae2f663bf8e0a7dfe3f612ad9ed409260\">◆&nbsp;<\/a><\/span>I2C_IntDisable()<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n<table class=\"mlabels\">\n  <tbody><tr>\n  <td class=\"mlabels-left\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">void I2C_IntDisable <\/td>\n          <td>(<\/td>\n          <td class=\"paramtype\">I2C_TypeDef *&nbsp;<\/td>\n          <td class=\"paramname\"><code>i2c, <\/code><\/td>\n        <\/tr>\n        <tr>\n          <td class=\"paramkey\"><\/td>\n          <td><\/td>\n          <td class=\"paramtype\">uint32_t&nbsp;<\/td>\n          <td class=\"paramname\"><code>flags&nbsp;<\/code><\/td>\n        <\/tr>\n        <tr>\n          <td><\/td>\n          <td>)<\/td>\n          <td><\/td><td><\/td>\n        <\/tr>\n      <\/tbody><\/table>\n  <\/td>\n  <td class=\"mlabels-right\">\n<span class=\"mlabels\"><span class=\"mlabel\">inline<\/span><\/span>  <\/td>\n  <\/tr>\n<\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Disable one or more I2C interrupts. <\/p>\n<dl class=\"params\"><dt>Parameters<\/dt><dd>\n  <table class=\"params\">\n    <tbody><tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>i2c<\/code><\/td><td>Pointer to I2C peripheral register block.<\/td><\/tr>\n    <tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>flags<\/code><\/td><td>I2C interrupt sources to disable. Use a bitwise logic OR combination of valid interrupt flags for the I2C module (I2C_IF_nnn). <\/td><\/tr>\n  <\/tbody><\/table>\n  <\/dd>\n<\/dl>\n\n<\/div>\n<\/div>\n<a id=\"ga4e7ec23adf30a399590113d8b98ec4f1\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#ga4e7ec23adf30a399590113d8b98ec4f1\">◆&nbsp;<\/a><\/span>I2C_IntEnable()<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n<table class=\"mlabels\">\n  <tbody><tr>\n  <td class=\"mlabels-left\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">void I2C_IntEnable <\/td>\n          <td>(<\/td>\n          <td class=\"paramtype\">I2C_TypeDef *&nbsp;<\/td>\n          <td class=\"paramname\"><code>i2c, <\/code><\/td>\n        <\/tr>\n        <tr>\n          <td class=\"paramkey\"><\/td>\n          <td><\/td>\n          <td class=\"paramtype\">uint32_t&nbsp;<\/td>\n          <td class=\"paramname\"><code>flags&nbsp;<\/code><\/td>\n        <\/tr>\n        <tr>\n          <td><\/td>\n          <td>)<\/td>\n          <td><\/td><td><\/td>\n        <\/tr>\n      <\/tbody><\/table>\n  <\/td>\n  <td class=\"mlabels-right\">\n<span class=\"mlabels\"><span class=\"mlabel\">inline<\/span><\/span>  <\/td>\n  <\/tr>\n<\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Enable one or more I2C interrupts. <\/p>\n<dl class=\"section note\"><dt>Note<\/dt><dd>Depending on the use, a pending interrupt may already be set prior to enabling the interrupt. To ignore a pending interrupt, consider using <a href=\"#ga6cba16ae44e25e0e9f85e7fdf9f09956\" class=\"el\" title=\"Clear one or more pending I2C interrupts.\">I2C_IntClear()<\/a> prior to enabling the interrupt.<\/dd><\/dl>\n<dl class=\"params\"><dt>Parameters<\/dt><dd>\n  <table class=\"params\">\n    <tbody><tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>i2c<\/code><\/td><td>Pointer to I2C peripheral register block.<\/td><\/tr>\n    <tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>flags<\/code><\/td><td>I2C interrupt sources to enable. Use a bitwise logic OR combination of valid interrupt flags for the I2C module (I2C_IF_nnn). <\/td><\/tr>\n  <\/tbody><\/table>\n  <\/dd>\n<\/dl>\n\n<\/div>\n<\/div>\n<a id=\"gad969f558d7a35d5235dd174c9eb3aed0\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#gad969f558d7a35d5235dd174c9eb3aed0\">◆&nbsp;<\/a><\/span>I2C_IntGet()<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n<table class=\"mlabels\">\n  <tbody><tr>\n  <td class=\"mlabels-left\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">uint32_t I2C_IntGet <\/td>\n          <td>(<\/td>\n          <td class=\"paramtype\">I2C_TypeDef *&nbsp;<\/td>\n          <td class=\"paramname\"><code>i2c<\/code><\/td><td>)<\/td>\n          <td><\/td>\n        <\/tr>\n      <\/tbody><\/table>\n  <\/td>\n  <td class=\"mlabels-right\">\n<span class=\"mlabels\"><span class=\"mlabel\">inline<\/span><\/span>  <\/td>\n  <\/tr>\n<\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Get pending I2C interrupt flags. <\/p>\n<dl class=\"section note\"><dt>Note<\/dt><dd>Event bits are not cleared by the use of this function.<\/dd><\/dl>\n<dl class=\"params\"><dt>Parameters<\/dt><dd>\n  <table class=\"params\">\n    <tbody><tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>i2c<\/code><\/td><td>Pointer to I2C peripheral register block.<\/td><\/tr>\n  <\/tbody><\/table>\n  <\/dd>\n<\/dl>\n<dl class=\"section return\"><dt>Returns<\/dt><dd>I2C interrupt sources pending. A bitwise logic OR combination of valid interrupt flags for the I2C module (I2C_IF_nnn). <\/dd><\/dl>\n\n<\/div>\n<\/div>\n<a id=\"gab808cebf4e4caca28c4cf59b4d596b32\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#gab808cebf4e4caca28c4cf59b4d596b32\">◆&nbsp;<\/a><\/span>I2C_IntGetEnabled()<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n<table class=\"mlabels\">\n  <tbody><tr>\n  <td class=\"mlabels-left\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">uint32_t I2C_IntGetEnabled <\/td>\n          <td>(<\/td>\n          <td class=\"paramtype\">I2C_TypeDef *&nbsp;<\/td>\n          <td class=\"paramname\"><code>i2c<\/code><\/td><td>)<\/td>\n          <td><\/td>\n        <\/tr>\n      <\/tbody><\/table>\n  <\/td>\n  <td class=\"mlabels-right\">\n<span class=\"mlabels\"><span class=\"mlabel\">inline<\/span><\/span>  <\/td>\n  <\/tr>\n<\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Get enabled and pending I2C interrupt flags. <\/p>\n<p>Useful for handling more interrupt sources in the same interrupt handler.<\/p>\n<dl class=\"section note\"><dt>Note<\/dt><dd>Interrupt flags are not cleared by the use of this function.<\/dd><\/dl>\n<dl class=\"params\"><dt>Parameters<\/dt><dd>\n  <table class=\"params\">\n    <tbody><tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>i2c<\/code><\/td><td>Pointer to I2C peripheral register block.<\/td><\/tr>\n  <\/tbody><\/table>\n  <\/dd>\n<\/dl>\n<dl class=\"section return\"><dt>Returns<\/dt><dd>Pending and enabled I2C interrupt sources Return value is the bitwise AND of<ul>\n<li>the enabled interrupt sources in I2Cn_IEN and<\/li>\n<li>the pending interrupt flags I2Cn_IF <\/li>\n<\/ul>\n<\/dd><\/dl>\n\n<\/div>\n<\/div>\n<a id=\"gab76ed891da5ae8e6736d22a9570cb4a5\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#gab76ed891da5ae8e6736d22a9570cb4a5\">◆&nbsp;<\/a><\/span>I2C_IntSet()<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n<table class=\"mlabels\">\n  <tbody><tr>\n  <td class=\"mlabels-left\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">void I2C_IntSet <\/td>\n          <td>(<\/td>\n          <td class=\"paramtype\">I2C_TypeDef *&nbsp;<\/td>\n          <td class=\"paramname\"><code>i2c, <\/code><\/td>\n        <\/tr>\n        <tr>\n          <td class=\"paramkey\"><\/td>\n          <td><\/td>\n          <td class=\"paramtype\">uint32_t&nbsp;<\/td>\n          <td class=\"paramname\"><code>flags&nbsp;<\/code><\/td>\n        <\/tr>\n        <tr>\n          <td><\/td>\n          <td>)<\/td>\n          <td><\/td><td><\/td>\n        <\/tr>\n      <\/tbody><\/table>\n  <\/td>\n  <td class=\"mlabels-right\">\n<span class=\"mlabels\"><span class=\"mlabel\">inline<\/span><\/span>  <\/td>\n  <\/tr>\n<\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Set one or more pending I2C interrupts from SW. <\/p>\n<dl class=\"params\"><dt>Parameters<\/dt><dd>\n  <table class=\"params\">\n    <tbody><tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>i2c<\/code><\/td><td>Pointer to I2C peripheral register block.<\/td><\/tr>\n    <tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>flags<\/code><\/td><td>I2C interrupt sources to set to pending. Use a bitwise logic OR combination of valid interrupt flags for the I2C module (I2C_IF_nnn). <\/td><\/tr>\n  <\/tbody><\/table>\n  <\/dd>\n<\/dl>\n\n<\/div>\n<\/div>\n<a id=\"ga602a1d2c64c05453bf9c1b1d52194678\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#ga602a1d2c64c05453bf9c1b1d52194678\">◆&nbsp;<\/a><\/span>I2C_Reset()<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">void I2C_Reset <\/td>\n          <td>(<\/td>\n          <td class=\"paramtype\">I2C_TypeDef *&nbsp;<\/td>\n          <td class=\"paramname\"><code>i2c<\/code><\/td><td>)<\/td>\n          <td><\/td>\n        <\/tr>\n      <\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Reset I2C to the same state that it was in after a hardware reset. <\/p>\n<dl class=\"section note\"><dt>Note<\/dt><dd>The ROUTE register is NOT reset by this function to allow for centralized setup of this feature.<\/dd><\/dl>\n<dl class=\"params\"><dt>Parameters<\/dt><dd>\n  <table class=\"params\">\n    <tbody><tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>i2c<\/code><\/td><td>A pointer to the I2C peripheral register block. <\/td><\/tr>\n  <\/tbody><\/table>\n  <\/dd>\n<\/dl>\n\n<\/div>\n<\/div>\n<a id=\"gab7373d2618562755e7f57753c824417e\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#gab7373d2618562755e7f57753c824417e\">◆&nbsp;<\/a><\/span>I2C_SlaveAddressGet()<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n<table class=\"mlabels\">\n  <tbody><tr>\n  <td class=\"mlabels-left\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">uint8_t I2C_SlaveAddressGet <\/td>\n          <td>(<\/td>\n          <td class=\"paramtype\">I2C_TypeDef *&nbsp;<\/td>\n          <td class=\"paramname\"><code>i2c<\/code><\/td><td>)<\/td>\n          <td><\/td>\n        <\/tr>\n      <\/tbody><\/table>\n  <\/td>\n  <td class=\"mlabels-right\">\n<span class=\"mlabels\"><span class=\"mlabel\">inline<\/span><\/span>  <\/td>\n  <\/tr>\n<\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Get Target address used for I2C peripheral (when operating in Target mode). <\/p>\n<p>For 10-bit addressing mode, the address is split in two bytes, and only the first byte setting is fetched, effectively only controlling the 2 most significant bits of the 10-bit address. Full handling of 10-bit addressing in Target mode requires additional SW handling.<\/p>\n<dl class=\"params\"><dt>Parameters<\/dt><dd>\n  <table class=\"params\">\n    <tbody><tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>i2c<\/code><\/td><td>Pointer to I2C peripheral register block.<\/td><\/tr>\n  <\/tbody><\/table>\n  <\/dd>\n<\/dl>\n<dl class=\"section return\"><dt>Returns<\/dt><dd>I2C Target address in use. The 7 most significant bits define the actual address, the least significant bit is reserved and always returned as 0. <\/dd><\/dl>\n\n<\/div>\n<\/div>\n<a id=\"gaf6c8d330247b9da600468307689f7df0\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#gaf6c8d330247b9da600468307689f7df0\">◆&nbsp;<\/a><\/span>I2C_SlaveAddressSet()<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n<table class=\"mlabels\">\n  <tbody><tr>\n  <td class=\"mlabels-left\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">void I2C_SlaveAddressSet <\/td>\n          <td>(<\/td>\n          <td class=\"paramtype\">I2C_TypeDef *&nbsp;<\/td>\n          <td class=\"paramname\"><code>i2c, <\/code><\/td>\n        <\/tr>\n        <tr>\n          <td class=\"paramkey\"><\/td>\n          <td><\/td>\n          <td class=\"paramtype\">uint8_t&nbsp;<\/td>\n          <td class=\"paramname\"><code>addr&nbsp;<\/code><\/td>\n        <\/tr>\n        <tr>\n          <td><\/td>\n          <td>)<\/td>\n          <td><\/td><td><\/td>\n        <\/tr>\n      <\/tbody><\/table>\n  <\/td>\n  <td class=\"mlabels-right\">\n<span class=\"mlabels\"><span class=\"mlabel\">inline<\/span><\/span>  <\/td>\n  <\/tr>\n<\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Set Target address to use for I2C peripheral (when operating in Target mode). <\/p>\n<p>For 10- bit addressing mode, the address is split in two bytes, and only the first byte is set, effectively only controlling the 2 most significant bits of the 10-bit address. Full handling of 10-bit addressing in Target mode requires additional SW handling.<\/p>\n<dl class=\"params\"><dt>Parameters<\/dt><dd>\n  <table class=\"params\">\n    <tbody><tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>i2c<\/code><\/td><td>Pointer to I2C peripheral register block.<\/td><\/tr>\n    <tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>addr<\/code><\/td><td>I2C Target address to use. The 7 most significant bits define the actual address, the least significant bit is reserved and always set to 0. <\/td><\/tr>\n  <\/tbody><\/table>\n  <\/dd>\n<\/dl>\n\n<\/div>\n<\/div>\n<a id=\"gacb6d14f920b35944800b65b71347428c\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#gacb6d14f920b35944800b65b71347428c\">◆&nbsp;<\/a><\/span>I2C_SlaveAddressMaskGet()<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n<table class=\"mlabels\">\n  <tbody><tr>\n  <td class=\"mlabels-left\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">uint8_t I2C_SlaveAddressMaskGet <\/td>\n          <td>(<\/td>\n          <td class=\"paramtype\">I2C_TypeDef *&nbsp;<\/td>\n          <td class=\"paramname\"><code>i2c<\/code><\/td><td>)<\/td>\n          <td><\/td>\n        <\/tr>\n      <\/tbody><\/table>\n  <\/td>\n  <td class=\"mlabels-right\">\n<span class=\"mlabels\"><span class=\"mlabel\">inline<\/span><\/span>  <\/td>\n  <\/tr>\n<\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Get Target address mask used for I2C peripheral (when operating in Target mode). <\/p>\n<p>The address mask defines how the comparator works. A bit position with value 0 means that the corresponding Target address bit is ignored during comparison (don't care). A bit position with value 1 means that the corresponding Target address bit must match.<\/p>\n<p>For 10-bit addressing mode, the address is split in two bytes, and only the mask for the first address byte is fetched, effectively only controlling the 2 most significant bits of the 10-bit address.<\/p>\n<dl class=\"params\"><dt>Parameters<\/dt><dd>\n  <table class=\"params\">\n    <tbody><tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>i2c<\/code><\/td><td>Pointer to I2C peripheral register block.<\/td><\/tr>\n  <\/tbody><\/table>\n  <\/dd>\n<\/dl>\n<dl class=\"section return\"><dt>Returns<\/dt><dd>I2C Target address mask in use. The 7 most significant bits define the actual address mask, the least significant bit is reserved and always returned as 0. <\/dd><\/dl>\n\n<\/div>\n<\/div>\n<a id=\"ga386dbe1bb286a066925936d131f255ec\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#ga386dbe1bb286a066925936d131f255ec\">◆&nbsp;<\/a><\/span>I2C_SlaveAddressMaskSet()<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n<table class=\"mlabels\">\n  <tbody><tr>\n  <td class=\"mlabels-left\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">void I2C_SlaveAddressMaskSet <\/td>\n          <td>(<\/td>\n          <td class=\"paramtype\">I2C_TypeDef *&nbsp;<\/td>\n          <td class=\"paramname\"><code>i2c, <\/code><\/td>\n        <\/tr>\n        <tr>\n          <td class=\"paramkey\"><\/td>\n          <td><\/td>\n          <td class=\"paramtype\">uint8_t&nbsp;<\/td>\n          <td class=\"paramname\"><code>mask&nbsp;<\/code><\/td>\n        <\/tr>\n        <tr>\n          <td><\/td>\n          <td>)<\/td>\n          <td><\/td><td><\/td>\n        <\/tr>\n      <\/tbody><\/table>\n  <\/td>\n  <td class=\"mlabels-right\">\n<span class=\"mlabels\"><span class=\"mlabel\">inline<\/span><\/span>  <\/td>\n  <\/tr>\n<\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Set Target address mask used for I2C peripheral (when operating in Target mode). <\/p>\n<p>The address mask defines how the comparator works. A bit position with value 0 means that the corresponding Target address bit is ignored during comparison (don't care). A bit position with value 1 means that the corresponding Target address bit must match.<\/p>\n<p>For 10-bit addressing mode, the address is split in two bytes, and only the mask for the first address byte is set, effectively only controlling the 2 most significant bits of the 10-bit address.<\/p>\n<dl class=\"params\"><dt>Parameters<\/dt><dd>\n  <table class=\"params\">\n    <tbody><tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>i2c<\/code><\/td><td>Pointer to I2C peripheral register block.<\/td><\/tr>\n    <tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>mask<\/code><\/td><td>I2C Target address mask to use. The 7 most significant bits define the actual address mask, the least significant bit is reserved and should be 0. <\/td><\/tr>\n  <\/tbody><\/table>\n  <\/dd>\n<\/dl>\n\n<\/div>\n<\/div>\n<a id=\"ga67983b3dbe7f028a97f765e421b3df56\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#ga67983b3dbe7f028a97f765e421b3df56\">◆&nbsp;<\/a><\/span>I2C_Transfer()<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\"><a href=\"#ga7c781ec28ae11e3e28892de7aa07a00f\" class=\"el\">I2C_TransferReturn_TypeDef<\/a> I2C_Transfer <\/td>\n          <td>(<\/td>\n          <td class=\"paramtype\">I2C_TypeDef *&nbsp;<\/td>\n          <td class=\"paramname\"><code>i2c<\/code><\/td><td>)<\/td>\n          <td><\/td>\n        <\/tr>\n      <\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Continue an initiated I2C transfer (single master mode only). <\/p>\n<p>This function is used repeatedly after a <a href=\"#gae2bf2ecc3d0c4f55e3511d4871b64b16\" class=\"el\" title=\"Prepare and start an I2C transfer (single master mode only).\">I2C_TransferInit()<\/a> to complete a transfer. It may be used in polled mode as the below example shows: <\/p><div class=\"fragment\"><div class=\"line\"><a href=\"#ga7c781ec28ae11e3e28892de7aa07a00f\" class=\"code\">I2C_TransferReturn_TypeDef<\/a> ret;<\/div>\n<div class=\"line\"> <\/div>\n<div class=\"line\"><span class=\"comment\">// Do a polled transfer<\/span><\/div>\n<div class=\"line\">ret = <a href=\"#gae2bf2ecc3d0c4f55e3511d4871b64b16\" class=\"code\">I2C_TransferInit<\/a>(I2C0, seq);<\/div>\n<div class=\"line\"><span class=\"keywordflow\">while<\/span> (ret == <a href=\"#gga7c781ec28ae11e3e28892de7aa07a00fa1f1df5a76a71b423083d6a327d38ca1c\" class=\"code\">i2cTransferInProgress<\/a>)<\/div>\n<div class=\"line\">{<\/div>\n<div class=\"line\">  ret = <a href=\"#ga67983b3dbe7f028a97f765e421b3df56\" class=\"code\">I2C_Transfer<\/a>(I2C0);<\/div>\n<div class=\"line\">}<\/div>\n<\/div><!-- fragment --><p> It may also be used in interrupt driven mode, where this function is invoked from the interrupt handler. Notice that, if used in interrupt mode, NVIC interrupts must be configured and enabled for the I2C bus used. I2C peripheral specific interrupts are managed by this software.<\/p>\n<dl class=\"section note\"><dt>Note<\/dt><dd>Only single master mode is supported.<\/dd><\/dl>\n<dl class=\"params\"><dt>Parameters<\/dt><dd>\n  <table class=\"params\">\n    <tbody><tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>i2c<\/code><\/td><td>A pointer to the I2C peripheral register block.<\/td><\/tr>\n  <\/tbody><\/table>\n  <\/dd>\n<\/dl>\n<dl class=\"section return\"><dt>Returns<\/dt><dd>Returns status for an ongoing transfer. <ul>\n<li><a href=\"#gga7c781ec28ae11e3e28892de7aa07a00fa1f1df5a76a71b423083d6a327d38ca1c\" class=\"el\" title=\"Transfer in progress.\">i2cTransferInProgress<\/a> - indicates that transfer not finished. <\/li>\n<li><a href=\"#gga7c781ec28ae11e3e28892de7aa07a00fa01149f9a11ada8a9b05e7104f873de66\" class=\"el\" title=\"Transfer completed successfully.\">i2cTransferDone<\/a> - transfer completed successfully. <\/li>\n<li>otherwise some sort of error has occurred. <\/li>\n<\/ul>\n<\/dd><\/dl>\n\n<\/div>\n<\/div>\n<a id=\"gae2bf2ecc3d0c4f55e3511d4871b64b16\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#gae2bf2ecc3d0c4f55e3511d4871b64b16\">◆&nbsp;<\/a><\/span>I2C_TransferInit()<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\"><a href=\"#ga7c781ec28ae11e3e28892de7aa07a00f\" class=\"el\">I2C_TransferReturn_TypeDef<\/a> I2C_TransferInit <\/td>\n          <td>(<\/td>\n          <td class=\"paramtype\">I2C_TypeDef *&nbsp;<\/td>\n          <td class=\"paramname\"><code>i2c, <\/code><\/td>\n        <\/tr>\n        <tr>\n          <td class=\"paramkey\"><\/td>\n          <td><\/td>\n          <td class=\"paramtype\"><a href=\"http://docs.silabs.com/gecko-platform/4.1/emlib/api/efr32xg24/struct-i2-c-transfer-seq-type-def\" class=\"el\" target=\"_blank\">I2C_TransferSeq_TypeDef<\/a> *&nbsp;<\/td>\n          <td class=\"paramname\"><code>seq&nbsp;<\/code><\/td>\n        <\/tr>\n        <tr>\n          <td><\/td>\n          <td>)<\/td>\n          <td><\/td><td><\/td>\n        <\/tr>\n      <\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Prepare and start an I2C transfer (single master mode only). <\/p>\n<p>This function must be invoked to start an I2C transfer sequence. To complete the transfer, <a href=\"#ga67983b3dbe7f028a97f765e421b3df56\" class=\"el\" title=\"Continue an initiated I2C transfer (single master mode only).\">I2C_Transfer()<\/a> must be used either in polled mode or by adding a small driver wrapper using interrupts.<\/p>\n<dl class=\"section note\"><dt>Note<\/dt><dd>Only single master mode is supported.<\/dd><\/dl>\n<dl class=\"params\"><dt>Parameters<\/dt><dd>\n  <table class=\"params\">\n    <tbody><tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>i2c<\/code><\/td><td>A pointer to the I2C peripheral register block.<\/td><\/tr>\n    <tr><td class=\"paramdir\">[in]<\/td><td class=\"paramname\"><code>seq<\/code><\/td><td>A pointer to the sequence structure defining the I2C transfer to take place. The referenced structure must exist until the transfer has fully completed.<\/td><\/tr>\n  <\/tbody><\/table>\n  <\/dd>\n<\/dl>\n<dl class=\"section return\"><dt>Returns<\/dt><dd>Returns the status for an ongoing transfer: <ul>\n<li><a href=\"#gga7c781ec28ae11e3e28892de7aa07a00fa1f1df5a76a71b423083d6a327d38ca1c\" class=\"el\" title=\"Transfer in progress.\">i2cTransferInProgress<\/a> - indicates that the transfer is not finished. <\/li>\n<li>Otherwise, an error has occurred. <\/li>\n<\/ul>\n<\/dd><\/dl>\n\n<\/div>\n<\/div>\n<h2 class=\"groupheader\">Macro Definition Documentation<\/h2>\n<a id=\"ga0a2167eb1e00a8da86bf0826f712f0f8\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#ga0a2167eb1e00a8da86bf0826f712f0f8\">◆&nbsp;<\/a><\/span>I2C_FREQ_STANDARD_MAX<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">#define I2C_FREQ_STANDARD_MAX&nbsp;&nbsp;&nbsp;100000<\/td>\n        <\/tr>\n      <\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Standard mode max frequency assuming using 4:4 ratio for Nlow:Nhigh. <\/p>\n<p>From I2C specification: Min Tlow = 4.7us, min Thigh = 4.0us, max Trise=1.0us, max Tfall=0.3us. Since ratio is 4:4, have to use worst case value of Tlow or Thigh as base.<\/p>\n<p>1/(Tlow + Thigh + 1us + 0.3us) = 1/(4.7 + 4.7 + 1.3)us = 93458Hz <\/p><dl class=\"section note\"><dt>Note<\/dt><dd>Due to chip characteristics, max value is somewhat reduced. <\/dd><\/dl>\n\n<\/div>\n<\/div>\n<a id=\"ga29a3fbc14b30b68601118a9866e7440d\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#ga29a3fbc14b30b68601118a9866e7440d\">◆&nbsp;<\/a><\/span>I2C_FREQ_FAST_MAX<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">#define I2C_FREQ_FAST_MAX&nbsp;&nbsp;&nbsp;392157<\/td>\n        <\/tr>\n      <\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Fast mode max frequency assuming using 6:3 ratio for Nlow:Nhigh. <\/p>\n<p>From I2C specification: Min Tlow = 1.3us, min Thigh = 0.6us, max Trise=0.3us, max Tfall=0.3us. Since ratio is 6:3, have to use worst case value of Tlow or 2xThigh as base.<\/p>\n<p>1/(Tlow + Thigh + 0.3us + 0.3us) = 1/(1.3 + 0.65 + 0.6)us = 392157Hz <\/p>\n\n<\/div>\n<\/div>\n<a id=\"ga6961334be5d2f1d6e98d8f48de3b040e\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#ga6961334be5d2f1d6e98d8f48de3b040e\">◆&nbsp;<\/a><\/span>I2C_FREQ_FASTPLUS_MAX<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">#define I2C_FREQ_FASTPLUS_MAX&nbsp;&nbsp;&nbsp;987167<\/td>\n        <\/tr>\n      <\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Fast mode+ max frequency assuming using 11:6 ratio for Nlow:Nhigh. <\/p>\n<p>From I2C specification: Min Tlow = 0.5us, min Thigh = 0.26us, max Trise=0.12us, max Tfall=0.12us. Since ratio is 11:6, have to use worst case value of Tlow or (11/6)xThigh as base.<\/p>\n<p>1/(Tlow + Thigh + 0.12us + 0.12us) = 1/(0.5 + 0.273 + 0.24)us = 987167Hz <\/p>\n\n<\/div>\n<\/div>\n<a id=\"ga091476f45133e8a6deb9dbd7a3ea6229\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#ga091476f45133e8a6deb9dbd7a3ea6229\">◆&nbsp;<\/a><\/span>I2C_FLAG_WRITE<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">#define I2C_FLAG_WRITE&nbsp;&nbsp;&nbsp;0x0001<\/td>\n        <\/tr>\n      <\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Indicate plain write sequence: S+ADDR(W)+DATA0+P. <\/p>\n<ul>\n<li>S - Start <\/li>\n<li>ADDR(W) - address with W/R bit cleared <\/li>\n<li>DATA0 - Data taken from buffer with index 0 <\/li>\n<li>P - Stop <\/li>\n<\/ul>\n\n<\/div>\n<\/div>\n<a id=\"ga0c1779663a5ebf44e956ea3f591b4e61\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#ga0c1779663a5ebf44e956ea3f591b4e61\">◆&nbsp;<\/a><\/span>I2C_FLAG_READ<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">#define I2C_FLAG_READ&nbsp;&nbsp;&nbsp;0x0002<\/td>\n        <\/tr>\n      <\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Indicate plain read sequence: S+ADDR(R)+DATA0+P. <\/p>\n<ul>\n<li>S - Start <\/li>\n<li>ADDR(R) - Address with W/R bit set <\/li>\n<li>DATA0 - Data read into buffer with index 0 <\/li>\n<li>P - Stop <\/li>\n<\/ul>\n\n<\/div>\n<\/div>\n<a id=\"gaf9fc47d6ee1c66405dc491f7a4c3b8fc\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#gaf9fc47d6ee1c66405dc491f7a4c3b8fc\">◆&nbsp;<\/a><\/span>I2C_FLAG_WRITE_READ<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">#define I2C_FLAG_WRITE_READ&nbsp;&nbsp;&nbsp;0x0004<\/td>\n        <\/tr>\n      <\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Indicate combined write/read sequence: S+ADDR(W)+DATA0+Sr+ADDR(R)+DATA1+P. <\/p>\n<ul>\n<li>S - Start <\/li>\n<li>Sr - Repeated start <\/li>\n<li>ADDR(W) - Address with W/R bit cleared <\/li>\n<li>ADDR(R) - Address with W/R bit set <\/li>\n<li>DATAn - Data written from/read into buffer with index n <\/li>\n<li>P - Stop <\/li>\n<\/ul>\n\n<\/div>\n<\/div>\n<a id=\"ga28bb5f9d0559f3af24c0554e497ba2b3\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#ga28bb5f9d0559f3af24c0554e497ba2b3\">◆&nbsp;<\/a><\/span>I2C_FLAG_WRITE_WRITE<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">#define I2C_FLAG_WRITE_WRITE&nbsp;&nbsp;&nbsp;0x0008<\/td>\n        <\/tr>\n      <\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Indicate write sequence using two buffers: S+ADDR(W)+DATA0+DATA1+P. <\/p>\n<ul>\n<li>S - Start <\/li>\n<li>ADDR(W) - Address with W/R bit cleared <\/li>\n<li>DATAn - Data written from buffer with index n <\/li>\n<li>P - Stop <\/li>\n<\/ul>\n\n<\/div>\n<\/div>\n<a id=\"ga6fd13e29a6b6315de051549037ac176f\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#ga6fd13e29a6b6315de051549037ac176f\">◆&nbsp;<\/a><\/span>I2C_FLAG_10BIT_ADDR<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">#define I2C_FLAG_10BIT_ADDR&nbsp;&nbsp;&nbsp;0x0010<\/td>\n        <\/tr>\n      <\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Use 10 bit address. <\/p>\n\n<\/div>\n<\/div>\n<a id=\"ga5c7fbd27ef311914288d8e7ce02f1528\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#ga5c7fbd27ef311914288d8e7ce02f1528\">◆&nbsp;<\/a><\/span>I2C_INIT_DEFAULT<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">#define I2C_INIT_DEFAULT<\/td>\n        <\/tr>\n      <\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n<b>Value:<\/b><div class=\"fragment\"><div class=\"line\">  {                                                                        \\<\/div>\n<div class=\"line\">    true,                  <span class=\"comment\">/* Enable when initialization done. */<\/span>          \\<\/div>\n<div class=\"line\">    true,                  <span class=\"comment\">/* Set to Controller mode. */<\/span>                   \\<\/div>\n<div class=\"line\">    0,                     <span class=\"comment\">/* Use currently configured reference clock. */<\/span> \\<\/div>\n<div class=\"line\">    I2C_FREQ_STANDARD_MAX, <span class=\"comment\">/* Set to standard rate assuring being */<\/span>       \\<\/div>\n<div class=\"line\">    <span class=\"comment\">/*                        within I2C specification. */<\/span>                 \\<\/div>\n<div class=\"line\">    i2cClockHLRStandard    <span class=\"comment\">/* Set to use 4:4 low/high duty cycle. */<\/span>       \\<\/div>\n<div class=\"line\">  }<\/div>\n<\/div><!-- fragment -->\n<p>Suggested default configuration for I2C initialization structure. <\/p>\n\n<\/div>\n<\/div>\n<h2 class=\"groupheader\">Enumeration Type Documentation<\/h2>\n<a id=\"gabb1516548b4528328682d6be09a3e3a5\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#gabb1516548b4528328682d6be09a3e3a5\">◆&nbsp;<\/a><\/span>I2C_ClockHLR_TypeDef<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">enum <a href=\"#gabb1516548b4528328682d6be09a3e3a5\" class=\"el\">I2C_ClockHLR_TypeDef<\/a><\/td>\n        <\/tr>\n      <\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Clock low to high ratio settings. <\/p>\n<table class=\"fieldtable\">\n<tbody><tr><th colspan=\"2\">Enumerator<\/th><\/tr><tr><td class=\"fieldname\"><a id=\"ggabb1516548b4528328682d6be09a3e3a5a72c81018da3424addf47b44341acd111\"><\/a>i2cClockHLRStandard&nbsp;<\/td><td class=\"fielddoc\"><p>Ratio is 4:4. <\/p>\n<\/td><\/tr>\n<tr><td class=\"fieldname\"><a id=\"ggabb1516548b4528328682d6be09a3e3a5a7bfc41c09113d46c1247b598c80a3b2e\"><\/a>i2cClockHLRAsymetric&nbsp;<\/td><td class=\"fielddoc\"><p>Ratio is 6:3. <\/p>\n<\/td><\/tr>\n<tr><td class=\"fieldname\"><a id=\"ggabb1516548b4528328682d6be09a3e3a5a177d1faa325c634cbf56d2a4b4de9425\"><\/a>i2cClockHLRFast&nbsp;<\/td><td class=\"fielddoc\"><p>Ratio is 11:3. <\/p>\n<\/td><\/tr>\n<\/tbody><\/table>\n\n<\/div>\n<\/div>\n<a id=\"ga7c781ec28ae11e3e28892de7aa07a00f\"><\/a>\n<h2 class=\"memtitle\"><span class=\"permalink\"><a href=\"#ga7c781ec28ae11e3e28892de7aa07a00f\">◆&nbsp;<\/a><\/span>I2C_TransferReturn_TypeDef<\/h2>\n\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tbody><tr>\n          <td class=\"memname\">enum <a href=\"#ga7c781ec28ae11e3e28892de7aa07a00f\" class=\"el\">I2C_TransferReturn_TypeDef<\/a><\/td>\n        <\/tr>\n      <\/tbody><\/table>\n<\/div><div class=\"memdoc\">\n\n<p>Return codes for single Controller mode transfer function. <\/p>\n<table class=\"fieldtable\">\n<tbody><tr><th colspan=\"2\">Enumerator<\/th><\/tr><tr><td class=\"fieldname\"><a id=\"gga7c781ec28ae11e3e28892de7aa07a00fa1f1df5a76a71b423083d6a327d38ca1c\"><\/a>i2cTransferInProgress&nbsp;<\/td><td class=\"fielddoc\"><p>Transfer in progress. <\/p>\n<\/td><\/tr>\n<tr><td class=\"fieldname\"><a id=\"gga7c781ec28ae11e3e28892de7aa07a00fa01149f9a11ada8a9b05e7104f873de66\"><\/a>i2cTransferDone&nbsp;<\/td><td class=\"fielddoc\"><p>Transfer completed successfully. <\/p>\n<\/td><\/tr>\n<tr><td class=\"fieldname\"><a id=\"gga7c781ec28ae11e3e28892de7aa07a00fa54895c4189c89f4410a3ce1a15822725\"><\/a>i2cTransferNack&nbsp;<\/td><td class=\"fielddoc\"><p>NACK received during transfer. <\/p>\n<\/td><\/tr>\n<tr><td class=\"fieldname\"><a id=\"gga7c781ec28ae11e3e28892de7aa07a00fa75da099dd69e053ee12d38fdd76a22e6\"><\/a>i2cTransferBusErr&nbsp;<\/td><td class=\"fielddoc\"><p>Bus error during transfer (misplaced START/STOP). <\/p>\n<\/td><\/tr>\n<tr><td class=\"fieldname\"><a id=\"gga7c781ec28ae11e3e28892de7aa07a00fac15d6d57e2c8b0fca04fc6fbd80b824e\"><\/a>i2cTransferArbLost&nbsp;<\/td><td class=\"fielddoc\"><p>Arbitration lost during transfer. <\/p>\n<\/td><\/tr>\n<tr><td class=\"fieldname\"><a id=\"gga7c781ec28ae11e3e28892de7aa07a00fa49fe8ab19b9167d78c4b2abec7a511fc\"><\/a>i2cTransferUsageFault&nbsp;<\/td><td class=\"fielddoc\"><p>Usage fault. <\/p>\n<\/td><\/tr>\n<tr><td class=\"fieldname\"><a id=\"gga7c781ec28ae11e3e28892de7aa07a00faa5de823251279b281dcabbd1ec4f693d\"><\/a>i2cTransferSwFault&nbsp;<\/td><td class=\"fielddoc\"><p>SW fault. <\/p>\n<\/td><\/tr>\n<\/tbody><\/table>\n\n<\/div>\n<\/div>\n<\/div>\n      <div ub-in-page=\"6062051aebaf71079a7b414b\"><\/div>\n      <\/article>\n    ","url":"http://docs.silabs.com/gecko-platform/4.1/emlib/api/efr32xg24/group-i2c","status":"success"}
